{"/home/travis/build/npmtest/node-npmtest-bedwetter/test.js":"/* istanbul instrument in package npmtest_bedwetter */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bedwetter/lib.npmtest_bedwetter.js":"/* istanbul instrument in package npmtest_bedwetter */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bedwetter = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bedwetter = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bedwetter/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bedwetter && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bedwetter */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bedwetter\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bedwetter.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bedwetter.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bedwetter.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bedwetter.__dirname + '/lib.npmtest_bedwetter.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/index.js":"module.exports = require('./lib');","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/index.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar Call = require('call');\nvar Hoek = require('hoek');\n// var pluralize = require('pluralize');\nvar BedWetters = {\n    create  : require('./actions/create'),\n    find    : require('./actions/find'),\n    findone : require('./actions/findOne'),\n    update  : require('./actions/update'),\n    destroy : require('./actions/destroy'),\n    populate: require('./actions/populate'),\n    add     : require('./actions/add'),\n    remove  : require('./actions/remove'),\n}\n\n\nvar internals = {};\n\ninternals.defaults = {\n    \n    populate: false,\n    prefix: '',\n    createdLocation: false,\n    //pluralize: false, TODO: support on opts.associationAttr and opts.model\n    \n    actAsUser: false,\n    userUrlPrefix: 'user', // this is in the url in lieu of /users/{id}\n    userModel: 'users', // since it's not in the url\n    userIdProperty: 'id', // on auth credentials\n    \n    setOwner: false,\n    requireOwner: false,\n    ownerAttr: 'owner',\n    ownerAttrs: {},\n    childOwnerAttr: 'owner',\n    childOwnerAttrs: {},\n\n    // Setting a deleted flag rather than destroying\n    deletedFlag: false, // destroy by default\n    deletedAttr: 'deleted',\n    deletedValue: 1,\n    \n    // Change pk field\n    pkAttr: false,\n    childPkAttr: false,\n    \n    // Omit, later also pick, etc.\n    omit: [],\n    \n    // A place for hooks\n    hooks: {\n        options: _.identity\n    },\n    \n    // A place for private info to get passed around\n    _private: {\n        actAsUserModifiedPath: false,\n        count: false\n    }\n    \n}\n\n/**\n * BedWet\n *\n * (see http://nodejs.org/api/documentation.html#documentation_stability_index)\n */\n\nexports.register = function(server, options, next) {\n\n    server.dependency('dogwater');\n    \n    server.handler('bedwetter', function(route, handlerOptions) {\n        \n        // handlerOptions come user-defined in route definition\n        // nothing should override these!\n        \n        var Dogwater = server.plugins.dogwater;\n    \n        var thisRouteOpts = _.cloneDeep(internals.defaults);\n        \n        // Plugin-level user-defined options\n        _.merge(thisRouteOpts, options)\n        \n        // Route-level user-defined options\n        _.merge(thisRouteOpts, handlerOptions);\n        \n        // Route-level info (should not override plugin options & handler options)\n        internals.setOptionsFromRouteInfo(route, thisRouteOpts);\n        \n        // Set associations now that the model is locked-down\n        // TODO: figure out why these don't stick when model grabbed from parseModel\n        var Model = Dogwater[thisRouteOpts.model];\n        \n        Hoek.assert(Model, 'Model `' + thisRouteOpts.model + '` must exist to build route.');\n        \n        // Don't overwrite associations if they've been set as an option for some reason\n        _.defaults(thisRouteOpts, {associations: internals.getAssociationsFromModel(Model)});\n        \n        thisRouteOpts = internals.normalizeOptions(thisRouteOpts);\n        \n        // Here's our little bed wetter!\n        var bedWetter = internals.determineBedWetter(route, thisRouteOpts);\n\n        return bedWetter(route, thisRouteOpts);\n        \n    });\n    \n    next();\n};\n\nexports.register.attributes = {\n    pkg: require('../package.json')\n};\n\n\ninternals.Router = new Call.Router({});\n\ninternals.determineBedWetter = function(route, thisRouteOpts) {\n    \n    var method  = route.method;\n    var path    = route.path;\n    \n    path = internals.normalizePath(path, thisRouteOpts);\n    \n    var pathInfo = internals.Router.analyze(path);\n    var pathSegments = pathInfo.segments.length;\n    var err;\n    \n    // Account for `update` allowing POST or PATCH\n    if (_.isArray(method) &&\n        method.length == 2 &&\n        _.intersection(method, ['post', 'patch']).length == 2) {\n        \n        method = 'patch';\n    }\n    \n    var countIsOkay = false;\n    var bedwetter;\n    switch (method) {\n        \n        case 'post':\n            \n            if (pathSegments == 1 &&\n                pathInfo.segments[0].literal) {         // model\n                \n                // Create\n                bedwetter = BedWetters.create;\n            \n            } else if (pathSegments == 2 &&\n                pathInfo.segments[0].literal &&         // model\n                pathInfo.segments[1].name) {            // record\n                \n                // Patched update\n                bedwetter = BedWetters.update;\n            \n            } else if (pathSegments == 3 &&\n                      pathInfo.segments[0].literal &&   // model\n                      pathInfo.segments[1].name &&      // record\n                      pathInfo.segments[2].literal) {   // association\n                \n                // Create and add to relation\n                bedwetter = BedWetters.add;\n            \n            } else {\n                err = new Error('This ' + method + ' route does not match a BedWetting pattern.');\n            }\n            \n            break;\n        \n        case 'patch':\n            \n            if (pathSegments == 2 &&\n                pathInfo.segments[0].literal &&   // model\n                pathInfo.segments[1].name) {      // record\n                \n                // Patched update\n                bedwetter = BedWetters.update;\n            \n            } else {\n                err = new Error('This ' + method + ' route does not match a BedWetting pattern.');\n            }\n            \n            break;\n        \n        case 'put':\n            \n            if (pathSegments == 4 &&\n                      pathInfo.segments[0].literal &&   // model\n                      pathInfo.segments[1].name &&      // record\n                      pathInfo.segments[2].literal &&   // association\n                      pathInfo.segments[3].name) {      // record_to_add\n                \n                // Add to a relation\n                bedwetter = BedWetters.add;\n            \n            } else {\n                err = new Error('This ' + method + ' route does not match a BedWetting pattern.');\n            }\n            \n            break;\n            \n        case 'get':\n            \n            if (pathSegments == 1 &&\n                pathInfo.segments[0].literal) {         // model\n                \n                countIsOkay = true;\n                \n                // Find with criteria\n                bedwetter = BedWetters.find;\n            \n            } else if (pathSegments == 2 &&\n                      pathInfo.segments[0].literal &&   // model\n                      pathInfo.segments[1].name) {      // record\n                \n                // Find one by id\n                bedwetter = BedWetters.findone;\n            \n            } else if (pathSegments == 3 &&\n                      pathInfo.segments[0].literal &&   // model\n                      pathInfo.segments[1].name &&      // record\n                      pathInfo.segments[2].literal) {   // association\n                \n                countIsOkay = true;\n                \n                // Get associated records\n                bedwetter = BedWetters.populate;\n            \n            } else if (pathSegments == 4 &&\n                      pathInfo.segments[0].literal &&   // model\n                      pathInfo.segments[1].name &&      // record\n                      pathInfo.segments[2].literal &&   // association\n                      pathInfo.segments[3].name) {      // record_to_check\n                \n                // Check for an association between records\n                bedwetter = BedWetters.populate;\n            \n            } else {\n                err = new Error('This ' + method + ' route does not match a BedWetting pattern.');\n            }\n            \n            break;\n        \n        case 'delete':\n            \n            if (pathSegments == 2 &&\n                pathInfo.segments[0].literal &&   // model\n                pathInfo.segments[1].name) {      // record\n                \n                bedwetter = BedWetters.destroy;\n            \n            } else if (pathSegments == 4 &&\n                      pathInfo.segments[0].literal &&   // model\n                      pathInfo.segments[1].name &&      // record\n                      pathInfo.segments[2].literal &&   // association\n                      pathInfo.segments[3].name) {      // record_to_remove\n                \n                bedwetter = BedWetters.remove;\n            \n            } else {\n                err = new Error('This ' + method + ' route does not match a BedWetting pattern.');\n            }\n            \n            break;\n        \n        default:\n            err = new Error('Method isn\\'t a BedWetter.  Must be POST, GET, DELETE, PUT, or PATCH.');\n            break;\n    }\n    \n    // Only allow counting on find and array populate\n    if (thisRouteOpts._private.count && !countIsOkay) {\n        err = new Error('This bedwetter can\\'t count!');\n    }\n    \n    if (err) {\n        throw err;\n    } else {\n        return bedwetter;\n    }\n    \n}\n\ninternals.setOptionsFromRouteInfo = function(route, thisRouteOpts) {\n    \n    var routeInfo = {};\n    \n    var path = internals.normalizePath(route.path, thisRouteOpts);\n    var pathInfo = internals.Router.analyze(path);\n    var pathSegments = pathInfo.segments.length;\n    \n    Hoek.assert(1 <= pathSegments && pathSegments <= 4, 'Number of path segments should be between 1 and 4.');\n    \n    switch (pathSegments) {\n        case 4:\n            routeInfo.associatedPkName = pathInfo.segments[3].name;\n        case 3:\n            routeInfo.associationAttr = pathInfo.segments[2].literal;\n        case 2:\n            routeInfo.pkName = pathInfo.segments[1].name;\n        case 1:\n            routeInfo.model = pathInfo.segments[0].literal;\n    }\n    \n    _.defaults(thisRouteOpts, routeInfo);\n    \n}\n\n// See https://github.com/balderdashy/sails/blob/master/lib/hooks/orm/build-orm.js#L65 [waterline v0.10.11]\ninternals.getAssociationsFromModel = function(thisModel) {\n    \n    return _.reduce(thisModel.attributes, function (associatedWith, attrDef, attrName) {\n        \n        if (typeof attrDef === 'object' && (attrDef.model || attrDef.collection)) {\n          var assoc = {\n            alias: attrName,\n            type: attrDef.model ? 'model' : 'collection'\n          };\n          if (attrDef.model) {\n            assoc.model = attrDef.model;\n          }\n          if (attrDef.collection) {\n            assoc.collection = attrDef.collection;\n          }\n          if (attrDef.via) {\n            assoc.via = attrDef.via;\n          }\n\n          associatedWith.push(assoc);\n        }\n        \n        return associatedWith;\n    \n    }, []);\n\n}\n\ninternals.normalizePath = function(path, thisRouteOpts) {\n    \n    Hoek.assert(_.isString(thisRouteOpts.userUrlPrefix) || !thisRouteOpts.userUrlPrefix, 'Option userUrlPrefix should only have a string or a falsy value.');\n    Hoek.assert(_.isString(thisRouteOpts.userModel) || !thisRouteOpts.userModel, 'Option userModel should only have a string or a falsy value.');\n    \n    // Deal with prefix option\n    path = internals.removePrefixFromPath(path, thisRouteOpts.prefix);\n    \n    // TODO: adjust bedwetters!\n    if (internals.pathEndsWith(path, '/count')) {\n        thisRouteOpts._private.count = true;\n        path = internals.removeSuffixFromPath(path, '/count');\n    }\n    \n    // Deal with user creds options.\n    if (thisRouteOpts.actAsUser &&\n        thisRouteOpts.userUrlPrefix &&\n        thisRouteOpts.userModel &&\n        internals.pathBeginsWith(path, thisRouteOpts.userUrlPrefix)) {\n        \n        thisRouteOpts._private.actAsUserModifiedPath = true;\n        \n        // Transform path to seem like it's of the form /users/{userId}...\n        path = internals.removePrefixFromPath(path, thisRouteOpts.userUrlPrefix);\n        path = '/' + thisRouteOpts.userModel + '/{userId}' + path;\n    }\n    \n    return path;\n}\n\ninternals.pathEndsWith = function(path, needle) {\n    \n    if (path.indexOf(needle) !== -1 &&\n        path.indexOf(needle) === path.length-needle.length) {\n        return true;\n    } else {\n        return false;\n    }\n    \n}\n\ninternals.removeSuffixFromPath = function(path, suffix) {\n    \n    if (internals.pathEndsWith(path, suffix)) {\n        return path.slice(0, path.length-suffix.length);\n    } else {\n        return path;\n    }\n    \n}\n\ninternals.pathBeginsWith = function(path, needle) {\n    \n    // Remove trailing slashes from needle\n    needle = needle.replace(/\\/+$/, '');\n    \n    // path begins with needle\n    var softBegins = (path.indexOf(needle) === 0);\n    \n    if (!softBegins) return false;\n    \n    // Assuming path begins with needle,\n    // make sure it takes up enitre query parts.\n    // We check this by seeing if removing needle would leave an empty string (they have equal lengths)\n    // or if removing needle would leave a '/' as the first character in the newly constructed path.\n    var hardBegins = (path.length == needle.length) || path[needle.length] === '/';\n    \n    if (!hardBegins) return false;\n    \n    // Passed the tests\n    return true;\n    \n}\n\ninternals.removePrefixFromPath = function(path, prefix) {\n    \n    Hoek.assert(_.isString(path), 'Path parameter should be a string')\n    Hoek.assert(!prefix || _.isString(prefix), 'Prefix parameter should be a string or falsy.')\n    \n    if (!prefix) {\n        return path;\n    }\n    \n    // Remove trailing slashes from prefix\n    prefix = prefix.replace(/\\/+$/, '');\n    \n    // If the path begins with the prefix, chop it off!\n    if (path.indexOf(prefix) === 0) {\n        path = path.slice(prefix.length);\n    }\n    \n    return path;\n    \n}\n\ninternals.normalizeOptions = function(options) {\n    \n    var partial = {\n        ownerAttrs: {},\n        childOwnerAttrs: {}\n    };\n    \n    // Currently just map *ownerAttr strings to *ownerAttrs objects, if not already set.\n    if (options.ownerAttr && options.userIdProperty && !options.ownerAttrs[options.ownerAttr]) {\n        partial.ownerAttrs[options.ownerAttr] = options.userIdProperty;\n    }\n    \n    delete options.ownerAttr;\n    \n    if (options.childOwnerAttr && options.userIdProperty && !options.childOwnerAttrs[options.childOwnerAttr]) {\n        partial.childOwnerAttrs[options.childOwnerAttr] = options.userIdProperty;\n    }\n    \n    delete options.childOwnerAttr;\n    \n    _.merge(options, partial);\n    \n    return options;\n    \n}\n\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/create.js":"/**\n * Module dependencies\n */\nvar Boom = require('boom');\nvar WL2Boom = require('waterline-to-boom');\nvar GeneralUtil = require('../generalUtil');\n\n/**\n * Create Record\n *\n * post /:modelIdentity\n *\n * An API call to find and return a single model instance from the data adapter\n * using the specified criteria.  If an id was specified, just the instance with\n * that unique id will be returned.\n * \n */\n\nmodule.exports = function createRecord (route, origOptions) {\n\t\n\treturn function(request, reply) {\n\t\t\n\t        // Transform the original options using options hook\n\t\tvar options = GeneralUtil.applyOptionsHook(request, origOptions);\n\t\t\n\t\tvar RequestState = request.plugins.bedwetter = {\n\t\t\taction: 'create',\n\t\t\toptions: options\n\t\t};\n\t\t\n\t\tvar actionUtil = require('../actionUtil')(request, options);\n\t\t\n\t\tvar Model = actionUtil.parseModel();\n\t\t\n\t\t// Create data object (monolithic combination of all parameters)\n\t\t// Omit the blacklisted params (like JSONP callback param, etc.)\n\t\tvar data = actionUtil.parseValues();\n\t\t\n\t\t// Create new instance of model using data from params\n\t\tModel.create(data).exec(function created (err, newInstance) {\n\t\t\t\n\t\t\t// Differentiate between waterline-originated validation errors\n\t\t\t// and serious underlying issues. Respond with badRequest if a\n\t\t\t// validation error is encountered, w/ validation info.\n\t\t\tif (err) return reply(WL2Boom(err));\n\t\t\t\n\t\t\tvar location = actionUtil.getCreatedLocation(newInstance.id);\n\t\t\t\n\t\t\t// Omit fields if necessary\n\t\t\tactionUtil.omitFields(newInstance);\n\t\t\t\n\t\t\t// \"HTTP 201 / Created\"\n\t\t\treply(newInstance).created(location);\n\t\t});\n\t}\n  \n};\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/generalUtil.js":"var _ = require('lodash');\n\nvar internals = {};\n\nmodule.exports = {\n    \n    applyOptionsHook: function(request, origOptions) {\n        \n        if (origOptions.hooks && typeof origOptions.hooks.options === \"function\") {\n            \n            return origOptions.hooks.options(_.cloneDeep(origOptions), request);\n        } else {\n            \n            return _.cloneDeep(origOptions);\n        }\n        \n    },\n    \n    // This pk comes in the form of waterline criteria: object, string, or int\n    pkToString: function(pk) {\n        \n        if (_.isObject(pk) && Object.keys(pk).length) {\n            \n            return String(pk[Object.keys(pk)[0]]);\n        } else {\n            \n            return String(pk);\n        }\n    }\n    \n}\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/find.js":"/**\n * Module dependencies\n */\nvar Boom        = require('boom');\nvar WL2Boom     = require('waterline-to-boom');\nvar _           = require('lodash');\nvar GeneralUtil = require('../generalUtil');\n\n/**\n * Find Records\n *\n *  get   /:modelIdentity\n *\n * An API call to find and return model instances from the data adapter\n * using the specified criteria.  If an id was specified, just the instance\n * with that unique id will be returned.\n *\n * Optional:\n * @param {Object} where       - the find criteria (passed directly to the ORM)\n * @param {Integer} limit      - the maximum number of records to send back (useful for pagination)\n * @param {Integer} skip       - the number of records to skip (useful for pagination)\n * @param {String} sort        - the order of returned records, e.g. `name ASC` or `age DESC`\n * \n */\n\nmodule.exports = function findRecords (route, origOptions) {\n  \n  return function(request, reply) {\n    \n    // Transform the original options using options hook\n    var options = GeneralUtil.applyOptionsHook(request, origOptions);\n    \n    var RequestState = request.plugins.bedwetter = {\n      action: 'find',\n      options: options\n    };\n    \n    var actionUtil  = require('../actionUtil')(request, options);\n    \n    // Look up the model\n    var Model = actionUtil.parseModel();\n    \n    // Lookup for records that match the specified criteria.  Are we just counting?\n    var query;\n    if (options._private.count) {\n      \n      query = Model.count()\n      .where( actionUtil.parseCriteria() );\n      \n    } else {\n      \n      query = Model.find()\n      .where( actionUtil.parseCriteria() )\n      .limit( actionUtil.parseLimit() )\n      .skip( actionUtil.parseSkip() )\n      .sort( actionUtil.parseSort() );\n      \n      // TODO: .populateEach(req.options);\n      query = actionUtil.populateEach(query);\n      \n    }\n    \n    query.exec(function found(err, matchingRecords) {\n      \n      if (err) return reply(WL2Boom(err));\n      \n      // Omit fields if necessary\n      if (!options._private.count) {\n        \n        actionUtil.omitFields(matchingRecords);\n      }\n      \n      // If count is set, this this an integer.  Otherwise, it's an array of matching records.\n      return reply(matchingRecords);\n      \n    });\n    \n  }\n};\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/findOne.js":"/**\n * Module dependencies\n */\nvar Boom = require('boom');\nvar WL2Boom = require('waterline-to-boom');\nvar GeneralUtil = require('../generalUtil');\n\n/**\n * Find One Record\n *\n * get /:modelIdentity/:id\n *\n * An API call to find and return a single model instance from the data adapter\n * using the specified id.\n *\n */\n\nmodule.exports = function findOneRecord (route, origOptions) {\n  \n  return function(request, reply) {\n    \n    // Transform the original options using options hook\n    var options = GeneralUtil.applyOptionsHook(request, origOptions);\n    \n    var RequestState = request.plugins.bedwetter = {\n      action: 'findone',\n      options: options\n    };\n    \n    var actionUtil = require('../actionUtil')(request, options);\n    \n    var Model = actionUtil.parseModel();\n    \n    // The primary key of the record\n    var pk;\n    \n    try {\n      pk = actionUtil.requirePk();\n    } catch(e) {\n      return reply(Boom.wrap(e)); \n    }\n    \n    var query = Model.findOne(pk).where(actionUtil.checkDeletedFlag());\n    \n    query = actionUtil.populateEach(query);\n    \n    query.exec(function found(err, matchingRecord) {\n      \n      if (err)\n        return reply(WL2Boom(err));\n      \n      if (!matchingRecord)\n        return reply(Boom.notFound('No record found with the specified `id`.'));\n      \n      if (!actionUtil.validOwnership(matchingRecord, false))\n        return reply(Boom.unauthorized());\n      \n      // Share primary record\n      RequestState.primaryRecord = matchingRecord;\n      \n      // Omit fields if necessary\n      actionUtil.omitFields(matchingRecord);\n      \n      reply(matchingRecord);\n      \n    });\n    \n  }\n  \n}\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/update.js":"/**\n * Module dependencies\n */\nvar Boom = require('boom');\nvar WL2Boom = require('waterline-to-boom');\nvar Async = require('async');\nvar GeneralUtil = require('../generalUtil');\n\n\n/**\n * Update One Record\n *\n * An API call to update a model instance with the specified `id`,\n * treating the other unbound parameters as attributes.\n *\n */\n\nmodule.exports = function updateOneRecord (route, origOptions) {\n  \n  return function(request, reply) {\n    \n    // Transform the original options using options hook\n    var options = GeneralUtil.applyOptionsHook(request, origOptions);\n    \n    var RequestState = request.plugins.bedwetter = {\n      action: 'update',\n      options: options\n    };\n    \n    var actionUtil = require('../actionUtil')(request, options);\n    \n    // Look up the model\n    var Model = actionUtil.parseModel();\n  \n    // Locate and validate the required `id` parameter.\n    var pk;\n    \n    try {\n      pk = actionUtil.requirePk();\n    } catch(e) {\n      return reply(Boom.wrap(e)); \n    }\n    \n    // Create `values` object (monolithic combination of all parameters)\n    // But omit the blacklisted params (like JSONP callback param, etc.)\n    var values = actionUtil.parseValues();\n  \n    // Find, update, then reply\n    Async.waterfall([\n      \n      // Find\n      function(cb) {\n        \n        // TODO: DRY this up with findOne?\n        Model.findOne(pk).exec(function found(err, matchingRecord) {\n          \n          if (err)\n            return cb(err);\n          \n          if (!matchingRecord)\n            return cb(Boom.notFound('No record found with the specified `id`.'));\n          \n          if (!actionUtil.validOwnership(matchingRecord, false))\n            return cb(Boom.unauthorized());\n          \n          return cb(null, matchingRecord);\n          \n        });\n      },\n      \n      // Update\n      function(matchingRecord, cb) {\n        \n        Model.update(matchingRecord[Model.primaryKey], values).exec(function updated(err, records) {\n            \n            // Differentiate between waterline-originated validation errors\n            // and serious underlying issues. Respond with badRequest if a\n            // validation error is encountered, w/ validation info.\n            if (err) return cb(err);\n      \n            // Because this should only update a single record and update\n            // returns an array, just use the first item.\n            if (!records || !records.length) {\n              return cb(Boom.notFound());\n            }\n            \n            var updatedRecord = records[0];\n            \n            //If more than one record was returned, something is amiss.\n            if (records.length > 1) {\n              // TODO: Log it\n            }\n            \n            return cb(null, updatedRecord);\n            \n        });\n        \n      }],\n      \n      // Reply\n      function(err, updatedRecord) {\n      \n        if (err) return reply(WL2Boom(err));\n        \n        // Share primary record\n        RequestState.primaryRecord = updatedRecord;\n        \n        // Omit fields if necessary\n        actionUtil.omitFields(updatedRecord);\n        \n        return reply(updatedRecord); \n        \n    });\n    \n  }\n};\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/destroy.js":"/**\n * Module dependencies\n */\nvar Boom = require('boom');\nvar WL2Boom = require('waterline-to-boom');\nvar GeneralUtil = require('../generalUtil');\n\n/**\n * Destroy One Record\n *\n * delete  /:modelIdentity/:id\n *\n * Destroys the single model instance with the specified `id` from\n * the data adapter for the given model if it exists.\n *\n */\nmodule.exports = function destroyOneRecord (route, origOptions) {\n  \n  return function(request, reply) {\n    \n    // Transform the original options using options hook\n    var options = GeneralUtil.applyOptionsHook(request, origOptions);\n    \n    var RequestState = request.plugins.bedwetter = {\n      action: 'destroy',\n      options: options\n    };\n    \n    var actionUtil = require('../actionUtil')(request, options);\n    \n    var Model = actionUtil.parseModel();\n    \n    // The primary key of the record\n    var pk;\n    \n    try {\n      pk = actionUtil.requirePk();\n    } catch(e) {\n      return reply(Boom.wrap(e)); \n    }\n    \n    Model.findOne(pk).exec(function foundRecord (err, record) {\n      \n      if (err)\n        return reply(WL2Boom(err));\n      \n      if(!record)\n        return reply(Boom.notFound('No record found with the specified `id`.'));\n      \n      if(!actionUtil.validOwnership(record, false))\n        return reply(Boom.unauthorized());\n      \n      // Check for setting of deleted flag rather than destroying\n      if(options.deletedFlag) {\n        \n        var values = {};\n        values[options.deletedAttr] = options.deletedValue;\n\n        Model.update(record[Model.primaryKey], values).exec(function updated(err, records) {\n            \n            if (err) return reply(WL2Boom(err));\n\n            // Share primary record\n            RequestState.primaryRecord = records[0];\n            \n            // \"HTTP 204 No Content\" means success\n            return reply().code(204);\n            \n        });\n        \n      } else {\n        \n        Model.destroy(record[Model.primaryKey]).exec(function destroyedRecord (err) {\n          \n          if (err) return reply(WL2Boom(err));\n          \n          // Share primary record\n          RequestState.primaryRecord = record;\n          \n          // \"HTTP 204 / No Content\" means success\n          return reply().code(204);\n          \n        });\n        \n      }\n      \n    });\n    \n  }\n  \n};\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/populate.js":"/**\n * Module dependencies\n */\nvar Boom = require('boom');\nvar WL2Boom = require('waterline-to-boom');\nvar _ = require('lodash');\nvar GeneralUtil = require('../generalUtil');\n\n/**\n * Populate an association\n *\n * get /model/:parentid/relation\n * get /model/:parentid/relation/:id\n *\n * @param {Object} where       - the find criteria (passed directly to the ORM)\n * @param {Integer} limit      - the maximum number of records to send back (useful for pagination)\n * @param {Integer} skip       - the number of records to skip (useful for pagination)\n * @param {String} sort        - the order of returned records, e.g. `name ASC` or `age DESC`\n *\n */\n\nmodule.exports = function expand(route, origOptions) {\n  \n  return function(request, reply) {\n    \n    // Transform the original options using options hook\n    var options = GeneralUtil.applyOptionsHook(request, origOptions);\n    \n    var RequestState = request.plugins.bedwetter = {\n      action: 'populate',\n      options: options\n    };\n    \n    var actionUtil = require('../actionUtil')(request, options);\n    \n    var Model = actionUtil.parseModel();\n    var relation = options.associationAttr;\n    \n    if (!relation || !Model) return reply(Boom.notFound());\n    \n    var parentPk;\n    \n    try {\n      parentPk = actionUtil.requirePk();\n    } catch(e) {\n      return reply(Boom.wrap(e)); \n    }\n    \n    // Determine whether to populate using a criteria, or the\n    // specified primary key of the child record, or with no\n    // filter at all.\n    var childPk = actionUtil.parsePk(true);\n    var criteria;\n    \n    if (childPk) {\n      \n      criteria = childPk;\n      \n    } else {\n      \n      if (options._private.count) {\n        \n        criteria = {\n          where:  actionUtil.parseCriteria(true)\n        };\n        \n      } else {\n      \n        criteria = {\n          where:  actionUtil.parseCriteria(true),\n          skip:   actionUtil.parseSkip(),\n          limit:  actionUtil.parseLimit(),\n          sort:   actionUtil.parseSort()\n        };  \n      \n      }\n    }\n    \n    Model\n      .findOne(parentPk)\n      .populate(relation, criteria)\n      .exec(function found(err, matchingRecord) {\n        \n        if (err)\n          return reply(WL2Boom(err));\n        \n        if (!matchingRecord)\n          return reply(Boom.notFound('No record found with the specified id.'));\n        \n        if (!actionUtil.validOwnership(matchingRecord, false))\n          return reply(Boom.unauthorized());\n        \n        if (!matchingRecord[relation])\n          return reply(Boom.notFound(util.format('Specified record (%s) is missing relation `%s`', GeneralUtil.pkToString(parentPk), relation)));\n        \n        // Share primary record\n        RequestState.primaryRecord = matchingRecord;\n        \n        // If looking for a particular relation, return that it exists or that it does not.\n        // Otherwise, just return the results.\n        if (childPk) {\n          \n          if (matchingRecord[relation].length) {\n            \n            if (actionUtil.validOwnership(matchingRecord[relation][0], true)) {\n              \n              // Share secondary record\n              RequestState.secondaryRecord = matchingRecord[relation][0];\n              \n              // The relation exists.  Acknowledge with \"204 No Content\"\n              return reply().code(204);\n            \n            } else {\n              \n              // Not authorized to check, didn't own child record\n              return reply(Boom.unauthorized());\n              \n            }\n            \n          } else {\n            \n            // The relation does not exist.  That's a 404!\n            return reply(Boom.notFound());\n          }\n          \n        } else {\n          \n          if (options._private.count) {\n            \n            // Here's your count!\n            return reply(matchingRecord[relation].length);\n            \n          } else {\n            \n            // Omit fields if necessary\n            actionUtil.omitFields(matchingRecord[relation]);\n            \n            // Here are your results\n            return reply(matchingRecord[relation]);\n          \n          }\n          \n        }\n        \n      \n      });\n    \n  }\n  \n};\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/add.js":"/**\n * Module dependencies\n */\nvar _ = require('lodash');\nvar Boom = require('boom');\nvar Hoek = require('hoek');\nvar Async = require('async');\nvar WL2Boom = require('waterline-to-boom');\nvar GeneralUtil = require('../generalUtil');\n\n/**\n * Add Record To Collection\n *\n * post  /:modelIdentity/:id/:collectionAttr/:childid\n *\n * Associate one record with the collection attribute of another.\n * e.g. add a Horse named \"Jimmy\" to a Farm's \"animals\".\n * If the record being added has a primary key value already, it will\n * just be linked.  If it doesn't, a new record will be created, then\n * linked appropriately.  In either case, the association is bidirectional.\n *\n */\n\nmodule.exports = function addToCollection (route, origOptions) {\n\n  return function (request, reply) {\n    \n    // Transform the original options using options hook\n    var options = GeneralUtil.applyOptionsHook(request, origOptions);\n    \n    var RequestState = request.plugins.bedwetter = {\n      action: 'add',\n      options: options\n    };\n    \n    var actionUtil = require('../actionUtil')(request, options);\n    \n    // Ensure a model and alias can be deduced from the request.\n    var Model = actionUtil.parseModel();\n    var relation = options.associationAttr;\n    \n    if (!relation) {\n      return reply(Boom.wrap(new Error('Missing required route option, `options.associationAttr`.')));\n    }\n\n    // The primary key of the parent record\n    var parentPk;\n    \n    try {\n      parentPk = actionUtil.requirePk();\n    } catch(e) {\n      return reply(Boom.wrap(e)); \n    }\n  \n    // Get the model class of the child in order to figure out the name of\n    // the primary key attribute.\n    \n    var associationAttr = _.findWhere(options.associations, { alias: relation });\n    Hoek.assert(_.isObject(associationAttr), 'Bad association.');\n    \n    var ChildModel = request.model[associationAttr.collection];\n    var childPkAttr = ChildModel.primaryKey;\n  \n  \n    // The child record to associate is defined by either...\n    var child;\n  \n    // ...a primary key:\n    var supposedChildPk = actionUtil.parsePk(true);\n    \n    // ...or an object of values:\n    if (!supposedChildPk)  { \n      \n      options.values = options.values || {};\n      options.values.blacklist = options.values.blacklist || [];\n      // Make sure nobody can specify the id of the child.\n      \n      // You either link a record with the id in the URL or create an enitrely new record without specifying the id!\n      options.values.blacklist.push(childPkAttr);\n      child = actionUtil.parseValues(true);\n      \n    }\n  \n    if (!child && !supposedChildPk) {\n      return reply(Boom.badRequest('You must specify the record to add (either the primary key of an existing record to link, or a new object without a primary key which will be used to create a record then link it.)'));\n    }\n  \n    var createdChild = false;\n  \n    Async.auto({\n  \n      // Look up the parent record\n      parent: function (cb) {\n        \n        Model.findOne(parentPk).exec(function foundParent(err, parentRecord) {\n          \n          if (err) return cb(err);\n          if (!parentRecord) return cb(Boom.notFound());\n          if (!actionUtil.validOwnership(parentRecord, false)) return cb(Boom.unauthorized());\n          if (!parentRecord[relation] || !parentRecord[relation].add) return cb(Boom.notFound());\n                    \n          cb(null, parentRecord);\n          \n        });\n      },\n  \n      // If a primary key was specified in the `child` object we parsed\n      // from the request, look it up to make sure it exists.  Send back its primary key value.\n      // This is here because, although you can do this with `.save()`, you can't actually\n      // get ahold of the created child record data, unless you create it first.\n      actualChild: ['parent', function(cb) {\n  \n        // Below, we use the primary key attribute to pull out the primary key value\n        // (which might not have existed until now, if the .add() resulted in a `create()`)\n  \n        // If the primary key was specified for the child record, we should try to find it\n        if (supposedChildPk) {\n          \n          ChildModel.findOne(supposedChildPk).exec(function foundChild(err, childRecord) {\n            \n            if (err) return cb(err);\n            \n            // Trying to associate a record that does not exist\n            if (!childRecord)\n              return cb(Boom.notFound());\n            \n            if (!actionUtil.validOwnership(childRecord, true))\n              return cb(Boom.unauthorized());\n            \n            // Otherwise use the one we found.\n            return cb(null, childRecord);\n          });\n          \n        } else { // Otherwise, it must be referring to a new thing, so create it.\n          \n          ChildModel.create(child).exec(function createdNewChild (err, newChildRecord) {\n            \n            if (err) return cb(err);\n            createdChild = true;\n            \n            return cb(null, newChildRecord);\n          });\n          \n        }\n        \n      }],\n  \n      // Add the child record to the parent's collection\n      add: ['parent', 'actualChild', function(cb, asyncData) {\n        \n        try {\n          \n          // `collection` is the parent record's collection we\n          // want to add the child to.\n          var collection = asyncData.parent[relation];\n          collection.add(asyncData.actualChild[childPkAttr]);\n          \n          return cb();\n        \n        } catch (err) {\n          \n          // TODO: could all this be simplified?  do we need try/catch for record.add?\n          // I think not.  It's just an Array.push: https://github.com/balderdashy/waterline/blob/4653f8a18016d2bcde9a70c90dd63a7c69381935/lib/waterline/model/lib/association.js\n          // On the flipside, what if this relation doesn't exist?  Test!!  Should this err be turned into a notFound, similarly to in the parent function?\n          // Okay now this relation is properly tested for in the parent function\n          if (err) {\n            return cb(err);\n          }\n          \n          return cb();\n        }\n        \n      }]\n    },\n  \n    // Finally, save the parent record\n    function readyToSave (err, asyncResults) {\n  \n      if (err) return reply(WL2Boom(err));\n      \n      asyncResults.parent.save(function saved(err, savedParent) {\n  \n        // Ignore `insert` errors for duplicate adds, as add is idempotent.\n        var isDuplicateInsertError = (err && typeof err === 'object' && err.length && err[0] && err[0].type === 'insert');\n        if (err && !isDuplicateInsertError) return reply(WL2Boom(err));\n        \n        // Share primary record\n        RequestState.primaryRecord = asyncResults.parent;\n        \n        if (createdChild) {\n          \n          var location = actionUtil.getCreatedLocation(asyncResults.actualChild[childPkAttr]);\n          \n          // Omit fields if necessary\n          actionUtil.omitFields(asyncResults.actualChild);\n          \n          return reply(asyncResults.actualChild).created(location);\n        \n        } else {\n          \n          // Share secondary record\n          RequestState.secondaryRecord = asyncResults.actualChild;\n          \n          // \"HTTP 204 / No Content\" means success\n          return reply().code(204);\n        }\n        \n      });\n  \n    }); // end async.auto\n    \n  }\n  \n};\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actions/remove.js":"/**\n * Module dependencies\n */\nvar Boom = require('boom');\nvar Hoek = require('hoek');\nvar WL2Boom = require('waterline-to-boom');\nvar _ = require('lodash');\nvar GeneralUtil = require('../generalUtil');\n\n/**\n * delete /model/:parentid/relation/:id\n * \n * Remove a member from an association\n *\n */\n\nmodule.exports = function remove(route, origOptions) {\n  \n  return function(request, reply) {\n    \n    // Transform the original options using options hook\n    var options = GeneralUtil.applyOptionsHook(request, origOptions);\n    \n    var RequestState = request.plugins.bedwetter = {\n      action: 'remove',\n      options: options\n    };\n    \n    var actionUtil = require('../actionUtil')(request, options);\n    \n    // Ensure a model and alias can be deduced from the request.\n    var Model = actionUtil.parseModel();\n    var relation = options.associationAttr;\n    \n    if (!relation) {\n      return reply(Boom.wrap(new Error('Missing required route option, `options.associationAttr`.')));\n    }\n  \n    var associationAttr = _.findWhere(options.associations, { alias: relation });\n    Hoek.assert(_.isObject(associationAttr), 'Bad association.');\n  \n    var ChildModel = request.model[associationAttr.collection];\n    var childPkAttr = ChildModel.primaryKey;\n  \n    // The primary key of the parent record\n    var parentPk;\n    \n    try {\n      parentPk = actionUtil.requirePk();\n    } catch(e) {\n      return reply(Boom.wrap(e)); \n    }\n  \n    // The primary key of the child record to remove\n    // from the aliased collection\n    var childPk;\n    \n    try {\n      childPk = actionUtil.requirePk(true);\n    } catch(e) {\n      return reply(Boom.wrap(e)); \n    }\n    \n    Model\n    .findOne(parentPk).populate(relation, childPk).exec(function found(err, parentRecord) {\n      \n      if (err)\n        return reply(WL2Boom(err));\n      \n      // That parent record wasn't found\n      if (!parentRecord)\n        return reply(Boom.notFound());\n      \n      // Check parent record owner\n      if (!actionUtil.validOwnership(parentRecord, false))\n        return reply(Boom.unauthorized());\n      \n      // That child record wasn't found.\n      if (!parentRecord[relation] || !parentRecord[relation][0])\n        return reply(Boom.notFound());\n      \n      // Check child record owner\n      if (!actionUtil.validOwnership(parentRecord[relation][0], true))\n        return reply(Boom.unauthorized());\n      \n      parentRecord[relation].remove(parentRecord[relation][0][childPkAttr]);\n      \n      parentRecord.save(function(err, parentRecordSaved) {\n        \n        if (err) return reply(WL2Boom(err));\n        \n        // Share primary and secondary records\n        RequestState.primaryRecord   = parentRecordSaved;\n        RequestState.secondaryRecord = parentRecord[relation][0];\n        \n        // \"HTTP 204 / No Content\" means success\n        return reply().code(204);\n        \n      });\n    });\n  \n  }\n};\n","/home/travis/build/npmtest/node-npmtest-bedwetter/node_modules/bedwetter/lib/actionUtil.js":"/**\n * Module dependencies\n */\nvar _ = require('lodash');\nvar mergeDefaults = require('merge-defaults');\nvar Boom = require('boom');\nvar Hoek = require('hoek');\nvar util = require('util');\n\n\n/**\n * Utility methods used in built-in blueprint actions.\n *\n * @type {Object}\n */\nmodule.exports = function(request, options) {\n    \n    return {\n    \n    /** \n     * Given a Waterline query, populate the appropriate/specified\n     * association attributes and return it so it can be chained\n     * further ( i.e. so you can .exec() it )\n     *\n     * @param  {Query} query         [waterline query object]\n     * @param  {Request} request\n     * @param  {Object} options\n     * @return {Query}\n     */\n    populateEach: function (query) {\n      var DEFAULT_POPULATE_LIMIT = 30;\n      var _options = options;\n      var aliasFilter = request.query.populate;\n      var shouldPopulate = _options.populate;\n\n      // Convert the string representation of the filter list to an Array. We\n      // need this to provide flexibility in the request param. This way both\n      // list string representations are supported:\n      //   /model?populate=alias1,alias2,alias3\n      //   /model?populate=[alias1,alias2,alias3]\n      if (typeof aliasFilter === 'string') {\n        aliasFilter = aliasFilter.replace(/\\[|\\]/g, '');\n        aliasFilter = (aliasFilter) ? aliasFilter.split(',') : [];\n      }\n      \n      return _(_options.associations).reduce(function populateEachAssociation (query, association) {\n  \n        // If an alias filter was provided, override the blueprint config.\n        if (aliasFilter) {\n          shouldPopulate = _.contains(aliasFilter, association.alias);\n        }\n        \n        // TODO: use max limit!\n        // Only populate associations if a population filter has been supplied\n        // with the request or if `populate` is set within the blueprint config.\n        // Population filters will override any value stored in the config.\n        //\n        // Additionally, allow an object to be specified, where the key is the\n        // name of the association attribute, and value is true/false\n        // (true to populate, false to not)\n        if (shouldPopulate) {\n          \n          var populationLimit =\n            _options['populate_'+association.alias+'_limit'] ||\n            _options.populateLimit ||\n            _options.limit ||\n            DEFAULT_POPULATE_LIMIT;\n\n          var opts = {limit: populationLimit};\n          // If the deleted flag is set, make sure those results aren't being included\n          if(_options.deletedFlag) {\n            var values = {};\n            values[_options.deletedAttr] = { '!': _options.deletedValue };\n            _.merge(opts, {where: values});\n          }\n            \n          return query.populate(association.alias, opts);\n        \n        } else {\n          \n          return query;\n          \n        }\n        \n      }, query);\n    },\n  \n  \n    /**\n     * Parse primary key value for use in a Waterline criteria\n     * (e.g. for `find`, `update`, or `destroy`)\n     *\n     * @param  {Request} request\n     * @param  {Object} options\n     * @param  {Boolean} child\n     * @return {Integer|String}\n     */\n    parsePk: function (child) {\n      \n      var primaryKeyParam;\n      \n      child = child || false;\n      \n      if (child) {\n        primaryKeyParam = options.associatedPkName;\n      }  else {\n        primaryKeyParam = options.pkName;\n      }\n      \n      //TODO: support these options..id for parent and child\n      var pk;\n      \n      // If actAsUser modified the path, grab the user's pk from auth credentials.\n      if (!child &&\n          options._private.actAsUserModifiedPath) {\n        \n        pk = this.getUserId();\n        \n      } else { // Otherwise, grab it as per usual.\n        \n        pk = options.id || (options.where && options.where.id) || request.params[primaryKeyParam];\n      }\n      \n      // TODO: make this smarter...\n      // (e.g. look for actual primary key of model and look for it\n      //  in the absence of `id`.)\n      // See coercePK for reference (although be aware it is not currently in use)\n  \n      // exclude criteria on id field\n      pk = _.isPlainObject(pk) ? undefined : pk;\n      \n      // If the primary key field for the record is specified, use it as criteria.\n      var tmpPk;\n      var pkAttr = child ? options.childPkAttr : options.pkAttr;\n      \n      if (typeof pk !== \"undefined\" && pkAttr) {\n        \n        tmpPk = {};\n        tmpPk[pkAttr] = pk;\n        pk = tmpPk;\n      }\n      \n      return pk;\n    },\n  \n  \n    /** \n     * Parse primary key value from parameters.\n     * Throw an error if it cannot be retrieved.\n     *\n     * @param  {Request} request\n     * @param  {Object} options\n     * @param  {Boolean} child\n     * @return {Integer|String}\n     */\n    requirePk: function (child) {\n      \n      child = child || false;\n      \n      var pk = this.parsePk(child);\n  \n      // Validate the required `id` parameter\n      if ( !pk ) {\n        \n        var err;\n        \n        // If path was modified for acting user, pk came from credentials.\n        if (!child &&\n            options._private.actAsUserModifiedPath) {\n          \n          err = Boom.unauthorized();\n          \n        } else {\n          \n          // TODO: error message here.\n          err = Boom.notFound();\n        }\n        \n        throw err;\n      }\n  \n      return pk;\n    },\n  \n  \n    /** \n     * Parse `criteria` for a Waterline `find` or `populate` from query parameters.\n     *\n     * @param  {Request} request\n     * @param  {Object} options\n     * @return {Object}            the WHERE criteria object\n     */\n    parseCriteria: function (child) {\n  \n      // Allow customizable blacklist for params NOT to include as criteria.\n      options.criteria = options.criteria || {};\n      options.criteria.blacklist = options.criteria.blacklist || ['limit', 'skip', 'sort', 'populate', 'omit'];\n  \n      // Validate blacklist to provide a more helpful error msg.\n      var blacklist = options.criteria && options.criteria.blacklist;\n      \n      Hoek.assert(_.isArray(blacklist), 'Invalid `options.criteria.blacklist`. Should be an array of strings (parameter names.)');\n  \n      // Look for explicitly specified `where` parameter.\n      var where = request.query.where;\n  \n      // If `where` parameter is a string, try to interpret it as JSON\n      if (_.isString(where)) {\n        where = tryToParseJSON(where);\n      }\n  \n      // If `where` has not been specified, but other unbound parameter variables\n      // **ARE** specified, build the `where` option using them.\n      if (!where) {\n  \n        // Prune params which aren't fit to be used as `where` criteria\n        // to build a proper where query\n        where = request.query;\n  \n        // Omit built-in runtime config (like query modifiers)\n        where = _.omit(where, blacklist || ['limit', 'skip', 'sort', 'omit']);\n  \n        // Omit any params w/ undefined values\n        where = _.omit(where, function (p){ return _.isUndefined(p); });\n  \n        // Omit jsonp callback param (but only if jsonp is enabled)\n        if (request.route.jsonp) {\n          delete where[request.route.jsonp]\n        }\n      }\n  \n      // Merge w/ options.where and return\n      where = _.merge({}, options.where || {}, where) || undefined;\n\n      where = _.merge(where, this.checkDeletedFlag());\n      \n      // Deal with ownership\n      if (options.actAsUser && options.requireOwner) {\n        \n        // Grab appropriate transformation object\n        var ownerAttrTransformation = child ? options.childOwnerAttrs : options.ownerAttrs;\n        Hoek.assert(_.isObject(ownerAttrTransformation), 'Owner attribute options (`options.childOwnerAttr`/`options.ownerAttr`/`options.childOwnerAttrs`/`options.ownerAttrs`) should be set for use with `options.requireOwner`.');\n        \n        // Get new values with transformation\n        var requireWhere = Hoek.transform(request.auth.credentials, ownerAttrTransformation);\n        \n        _.merge(where, requireWhere);\n        \n      }\n      \n      return where;\n    },\n  \n  \n    /** TODO\n     * Parse `values` for a Waterline `create` or `update` from all\n     * request parameters.\n     *\n     * @param  {Request} req\n     * @return {Object}\n     */\n    parseValues: function (child) {\n  \n      // Allow customizable blacklist for params NOT to include as values.\n      options.values = options.values || {};\n  \n      // Validate blacklist to provide a more helpful error msg.\n      var blacklist = options.values.blacklist || [];\n      Hoek.assert(_.isArray(blacklist), 'Invalid `options.values.blacklist`. Should be an array of strings (parameter names.)');\n  \n      // Merge payload into req.options.values, omitting the blacklist.\n      var values = mergeDefaults(_.cloneDeep(request.payload), _.omit(options.values, 'blacklist'));\n  \n      // Omit values that are in the blacklist (like query modifiers)\n      values = _.omit(values, blacklist);\n  \n      // Omit any values w/ undefined values\n      values = _.omit(values, function (p){ return _.isUndefined(p); });\n      \n      // Set owner value if we ought\n      if (options.actAsUser &&\n          options.setOwner) {\n        \n        // Grab appropriate transformation object\n        var ownerAttrTransformation = child ? options.childOwnerAttrs : options.ownerAttrs;\n        Hoek.assert(_.isObject(ownerAttrTransformation), 'Owner attribute options (`options.childOwnerAttr`/`options.ownerAttr`/`options.childOwnerAttrs`/`options.ownerAttrs`) should be set for use with `options.setOwner`.');\n        \n        // Get new values with transformation\n        var newValues = Hoek.transform(request.auth.credentials, ownerAttrTransformation);\n        \n        // Set new values\n        _.merge(values, newValues);\n        \n      }\n      \n      return values;\n    },\n  \n  \n    /**\n     * Determine the model class to use w/ this blueprint action.\n     * @param  {Request} request\n     * @param  {Object} options\n     * @return {WLCollection}\n     */\n    parseModel: function () {\n  \n      // Ensure a model can be deduced from the request options.\n      \n      var model = options.model;\n      if (!model) throw new Error(util.format('No `model` specified in route options.'));\n  \n      var Model = request.model[model];\n      if (!Model) throw new Error(util.format('Invalid route option, `model`.\\nI don\\'t know about any models named: `%s`',model));\n  \n      return Model;\n    },\n  \n  \n    /** \n     * @param  {Request} request\n     * @param  {Object} options\n     */\n    parseSort: function () {\n      return request.query.sort || options.sort || undefined;\n    },\n  \n  \n    /**\n     * @param  {Request} request\n     * @param  {Object} options\n     */\n    parseLimit: function () {\n      \n      var DEFAULT_LIMIT = 30;\n      var DEFAULT_MAX_LIMIT = 30;\n      \n      var requestedLimit = request.query.limit ?\n                            Math.abs(request.query.limit) || false :\n                            false;\n      \n      var maxLimit       = (typeof options.maxLimit !== 'undefined') ?\n                            options.maxLimit :\n                            DEFAULT_MAX_LIMIT;\n      \n      var limit;\n      \n      if (requestedLimit) {\n        \n        if (requestedLimit <= maxLimit) {\n          limit = requestedLimit;\n        } else {\n          limit = DEFAULT_LIMIT;\n        }\n        \n      } else if (typeof options.limit !== 'undefined') {\n        \n        limit = options.limit;\n      } else {\n        \n        limit = DEFAULT_LIMIT;\n      }\n      \n      // This is from sails.  What does it do?\n      // I suppose it would cast skip to something falsy if it were not a number.\n      if (limit) { limit = +limit; }\n      \n      return limit;\n    },\n  \n  \n    /** \n     * @param  {Request} request\n     * @param  {Object} options\n     */\n    parseSkip: function () {\n      var DEFAULT_SKIP = 0;\n      var skip = request.query.skip || (typeof options.skip !== 'undefined' ? options.skip : DEFAULT_SKIP);\n      \n      // This is from sails.  What does it do?\n      // I suppose it would cast skip to something falsy if it were not a number.\n      if (skip) { skip = +skip; }\n      \n      return skip;\n    },\n\n\n    /**\n     * Determine whether or not the deletedFlag should be included in where clause.\n     * @return {Object}\n     */\n    checkDeletedFlag: function() {\n      // If the deleted flag is set, make sure those results aren't being included\n      if(options.deletedFlag) {\n        var values = {};\n        values[options.deletedAttr] = { '!': options.deletedValue };\n        return values||{};\n      } else {\n        return {};\n      }\n    },\n  \n  \n    getUserId: function() {\n      \n      Hoek.assert(options.actAsUser, 'Not currently acting as user, per `options.actAsUser`.');\n      Hoek.assert(_.isString(options.userIdProperty), '`options.userIdProperty` must be a string.');\n      \n      // No creds, no user id.\n      if (!_.isObject(request.auth.credentials)) {\n        return false;\n      }\n      \n      var userId = Hoek.reach(request.auth.credentials, options.userIdProperty);\n      \n      return userId;\n    },\n  \n  \n    validOwnership: function(record, child) {\n      \n      if (!options.actAsUser || !options.requireOwner) {\n        return true;\n      }\n      \n      // Grab appropriate transformation object\n      var ownerAttrTransformation = child ? options.childOwnerAttrs : options.ownerAttrs;\n      Hoek.assert(_.isObject(ownerAttrTransformation), 'Owner attribute options (`options.childOwnerAttr`/`options.ownerAttr`/`options.childOwnerAttrs`/`options.ownerAttrs`) should be set for use with `options.requireOwner`.');\n      \n      // There're no owner attrs set for this record\n      if (_.isEmpty(ownerAttrTransformation)) {\n        return true;\n      }\n      \n      // Get new values with transformation\n      var requiredValues = Hoek.transform(request.auth.credentials, ownerAttrTransformation);\n      \n      // Check for a non-match\n      var requiredValue, recordOwnerValue;\n      for (var attributeName in requiredValues) {\n        requiredValue = requiredValues[attributeName];\n        \n        recordOwnerValue = record[attributeName];\n        Hoek.assert(!_.isUndefined(recordOwnerValue), 'Record does not have provided owner attribute `' + attributeName + '`.')\n        \n        if (recordOwnerValue != requiredValue) {\n          return false;\n        }\n        \n      }\n      \n      // Passed all the tests.\n      return true;\n      \n    },\n\n\n    getCreatedLocation: function(id) {\n      \n      if (options.createdLocation && id) {\n        return util.format(options.createdLocation, id);\n      } else {\n        return null;\n      }\n      \n    },\n    \n    // Apply options.omit and request.query.omit\n    omitFields: function(records) {\n        \n        // Grab omissions from options\n        var optionsOmissions = options.omit || [];\n        \n        if (!_.isArray(optionsOmissions)) {\n            \n            optionsOmissions = [optionsOmissions];\n        }\n        \n        // Grab omissions from query\n        var queryOmissions = request.query.omit || [];\n        \n        if (!_.isArray(queryOmissions)) {\n            \n            queryOmissions = [queryOmissions];\n        }\n        \n        // All omissions\n        var omissions = optionsOmissions.concat(queryOmissions)\n        \n        // If there are no omissions, peace\n        if (!omissions.length) {\n            \n            return records;\n        }\n        \n        // Make records array\n        var wasntArray = false;\n        if (!_.isArray(records)) {\n            \n            records = [records];\n            wasntArray = true;\n        }\n        \n        // Do the deed, omit keys on each record\n        records.forEach(function(record) {\n            \n            omitDeep(record, omissions);\n        });\n        \n        return wasntArray ? records[0] : records;\n    }\n\n  };\n  \n}\n\n// Attempt to parse JSON\n// If the parse fails, return the error object\n// If JSON is falsey, return null\n// (this is so that it will be ignored if not specified)\nfunction tryToParseJSON(json) {\n  if (!_.isString(json)) return null;\n  try {\n    return JSON.parse(json);\n  }\n  catch (e) { return e; }\n}\n\n// keys, an array of Hoek style deep keys, to omit from obj\nfunction omitDeep(obj, keys) {\n    \n    Hoek.assert(_.isArray(keys), 'Internal omitDeep function requires keys parameter to be an array.');\n    \n    var path, ref;\n    keys.forEach(function(key) {\n        \n        path = key.split('.');\n        ref = obj;\n        \n        for (var i = 0, il = path.length; i < il; ++i) {\n            var segment = path[i];\n            if (i + 1 === il) {\n                \n                if (_.isArray(ref)) {\n                    \n                    for (var j = 0, jl = ref.length; j < jl; ++j) {\n                        \n                        delete ref[j][segment];\n                    }\n                    \n                } else {\n                    \n                    delete ref[segment];\n                }\n                \n            }\n            \n            ref = ref[segment];\n        }\n    });\n    \n}\n"}